# mysql基础

> Author: **ghmark675**  
> Labels: **blog database**  
> Created: **2025-10-24T01:00:45Z**  
> Link and comments: <https://github.com/ghmark675/blog/issues/3>  


# 数据库（mysql）

# 基本概念

关系型数据库 - 二维表结构

# 操作

## DDL - 表操作 - 修改

```sql
alter table 表名 add 字段名 类型(长度) [comment 注释][约束];--添加字段
alter table 表名 modify 字段名 新数据类型(长度);--修改数据类型
alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释][约束];--修改字段名和字段类型
alter table 表名 drop 字段名;--删除字段
alter table 表名 rename to 新表名;--修改表名

drop table [if exists] 表名;--删除表

truncate table 表名;--删除表并重新创建表
```

## DML - 数据操作

1. 给指定字段添加数据

   ```sql
   insert into 表名 (字段1，字段2) values (值1，值2);--指定字段
   insert into 表名 values (值1，值2);--全部字段
   insert into 表名 (字段1，字段2) values (值1，值2),(值1，值2),(值1，值2);--批量添加指定字段
   insert into 表名 values (值1，值2),(值1，值2),(值1，值2);--批量添加全部字段
   ```

2. 修改数据

   ```sql
   update 表名 set 字段名1=值1,字段名2=值2,...[where condition];
   ```

3. 删除数据

   ```sql
   delete from 表名 [where condition];
   ```

## DQL - 数据查询

### 基本查询

```sql
select 字段1，字段2，字段3，... from 表名;--查询多个字段
select * from 表名;--查询所有字段
select 字段1 [as 别名1],字段2 [as 别名2] ... from 表名;--设置别名
select distinct 字段列表 from 表名;
```

### 条件查询

```sql
select 字段列表 from 表名 where conditions;
```

条件：

| 运算符        | 功能                                     |
| ------------- | ---------------------------------------- |
| `in(...)`     | 在in之后的列表中的值，多选1              |
| `like 占位符` | 模糊匹配(_匹配单个字符,%匹配任意个字符） |

### 聚合函数

| 函数    | 功能      |
| ------- | --------- |
| `count` | 统计数量· |
| `max`   | 最大值    |
| `min`   | 最小值    |
| `avg`   | 平均值    |
| `sum`   | 求和      |

```sql
select 聚合函数(字段列表) from 表名;
```

### 分组查询

```sql
select 字段列表 from 表名 [where condition] group by 分组字段名 [having 分组后过滤条件];
```

`where` 和 `having` 的区别:

* 执行时机：where 分组前过滤，不满足where条件不参与分组；having是分组之后对结果过滤
* 判断条件：where 不能对聚合函数进行判断, 而having可以

执行顺序: where > 聚合函数 > having

### 排序查询

```sql
select 字段列表 from 表名 order by 字段1 排序方式1, 字段2 排序方式2;
```

* asc 升序（默认）
* desc 降序

多字段排序，如果第一个字段相等，按第二个字段排

### 分页查询

```sql
select 字段列表 from 表名 limit 起始索引，查询记录数;
```

起始索引从0开始，起始索引=（查询页码-1）*每页显示记录数

### 执行顺序

```sql
from -> where -> group by -> having -> select -> order by -> limit
```

## DCL - 数据控制

1. 管理用户

   ```sql
   use mysql;
   select * from user;--查询用户
   
   create user 'username'@'hostname' identified by 'password';--创建用户
   
   alter user 'username'@'hostname' identified with mysql_native_password by 'new_password';--修改用户密码
   
   drop user 'username'@'hostname';
   ```

2. 权限控制

   ```sql
   show grants for 'username'@'hostname';--查询权限
   
   grant 权限列表 on 数据库名.表名 to 'username'@'hostname';--授予权限
   
   revoke 权限列表 on 数据库名.表名 from 'username'@'hostname';--撤销权限
   ```

# 约束

非空约束：限制该字段的数据不能为null

唯一约束：保证该字段的所有数据都是唯一、不重复的

主键约束：主键是一行数据的唯一标识，要求非空且唯一

默认约束：保存数据时，如果未指定该字段的值，则采用默认值

检查约束：保证字段值满足某一个条件

```sql
create table user(
    id int primary key auto_increment comment '主键',
    name varchar(10) not null unique comment '姓名',
    age int check (age > 0 && age <= 120) comment '年龄',
    status char(1) default 1 comment '状态',
    gender char(1)
);
```

外键约束：用来让两张表的数据之间建立连接，保证数据的一致性和完整性

```sql
create table 表名(
    [constraint] [外键名称] foreign key (外键字段名) references 主表(主表列名)
);

alter table 表名 add constraint 外键名称 foreign key (外键字段名) references 主表(主表列名);

alter table 表名 drop foreign key 外键名称;
```

| 行为        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| NO ACTION   | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。（与RESTRICT一致） |
| RESTRICT    | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。（与NOACTION一致) |
| CASCADE     | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录。 |
| SET NULL    | 当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为nul（这就要求该外键允许取null）。 |
| SET DEFAULT | 父表有变更时，子表将外键列设置成一个默认的值(Innodb不支持)   |

```sql
alter table 表名 add constraint 外键名称 foreign key (外键字段名) references 主表(主表列名) on update cascade on delete cascade;
```

# 多表

## 多表关系

* 一对多：在多的一方建立外键，指向“一”一方的主键
* 多对多：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键
* 一对一：拆分成两个表，任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（保证一对一）

## 多表查询

笛卡尔积：两个集合排列组合

### 内连接

A、B交集数据

```sql
select 字段列表 from 表1,表2 where condition;--隐式内连接
select 字段列表 from 表1 [ inner ] join 表2 on 连接条件;--显式内连接
```

### 外连接

左外连接：左表所有数据+两表交集部分数据

右外连接：右表所有数据+两表交集部分数据

## 联合查询

将多次查询 联合起来。必须有相同数量的列表

```sql
select 字段列表 from 表A ...
union [all]--不加all可以去重
select 字段列表 from 表B ... 
```

## 子查询

# 事务

事务 是一组操作的集合，是不可分割的工作单位

将所有操作作为一个整体一起向系统提交或撤销操作请求。**要么同时成功，要么同时失败**

## 事务操作

```sql
select @@autocommit;--查询事务自动提交状态（1为自动提交）
set @@autocommit = 0;--设置为手动提交
commit;--提交事务
rollback; --回滚事务，只要事务执行出错，就要进行回滚
```

```sql
start transaction或begin; --开启事务
commit;--提交事务
rollback;--回滚事务
```

## 四大特性

原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。

一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。

隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。

持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。

## 并发事务

脏读：一个事务读到另外一个事务还没有提交的数据。

不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。

幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了幻影”。

## 事务隔离级别

|       隔离级别        | 脏读 | 不可重复读 | 幻读 |
| :-------------------: | :--: | :--------: | :--: |
|   Read uncommitted    |  √   |     √      |  √   |
|    Read committed     |  ×   |     √      |  √   |
| Repeatable Read(默认) |  ×   |     ×      |  √   |
|     Serializable      |  ×   |     ×      |  ×   |

```sql
select @@transaction_isolation;--查看事务隔离级别
set [session|global] transaction isolation level {Read uncommitted|Read committed|Repeatable Read|Serializable}--设置隔离级别
```

# 存储引擎

## mysql体系结构

* 连接层

  最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户  
  端验证它所具有的操作权限。

* 服务层

  第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存  
  储引擎的功能也在这一层实现，如过程、函数等。

* 引擎层

  存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我  
  们可以根据自己的需要，来选取合适的存储引擎。

* 存储层

  主要是将数据存储在文件系统之上，并完成与存储引擎的交互。

## 存储引擎

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被  
称为表类型。

```sql
engine=innodb--设置存储引擎
show engines;--显示存储引擎
```

### InnoDB

逻辑存储结构

* TableSpace

  * Segment

    * Extent（1M）

      * Page（16K）

        * Row

InnoDB：是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致  
性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。

### MyISAM

不支持事务，不支持外键，支持表锁，不支持行锁，访问速度快

MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那  
么选择这个存储引擎是非常合适的。

### Memory

表数据存储在**内存**中

MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表  
无法缓存在内存中，而且无法保障数据的安全性。

# 索引

B+，hash

## 索引分类

* 主键索引

  针对于表中主键创建的索引

* 唯一索引

  避免同一个表中某数据列中的值重复

* 常规索引

  快速定位特定数据

* 全文索引

  全文索引查找的是文本中的关键词，而不是比较索引中的值

* 聚集索引

  将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据

  如果存在主键，主键索引就是聚集索引。

  如果不存在主键，将使用第一个唯一（UNIQUE）索引I作为聚集索引。

  如果表没有主键，或没有合适的唯一索引l，则lnnoDB会自动生成一个rowid作为隐藏的聚集索引l。

* 二级索引

  将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键

## 索引语法

```sql
create [unique|fulltext] index index_name on table_name(index_col_name...);--创建索引
show index from table_name;--查看索引
drop index index_name on table_name;--删除索引
```

## SQL执行频率

```sql
show [session|global] status like 'Com_______';--查看sql执行频率
```

慢查询日志：

`/var/lib/mysql/localhost-slow.log`

`修改配置文件/etc/mysql/my.cnf`

`/etc/mysql/mysql.conf.d/mysqld.cnf`

```ini
show_query_log=1
long_query_time=2
```

profile

```sql
set profiling = 1;--设置开启profiling
show profiles;--查看sql命令耗时
show profile for query 16;--检查queryid为16的命令具体耗时
```

## SQL性能分析

explain

```sql
explain select * from table_name where condition;--获取SQL语句信息
```

* id

  select查询的序列号，表示查询中执行select子句或者是操作表的顺序（id相同，执行顺序从上到下；id不同，值越大，越先执行)。

* select_type

  表示SELECT的类型，常见的取值有SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、  
  UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等

* type

  表示连接类型，性能由好到差的连接类型为NuLL、System、const、eq_ref、ref、range、index、all。

* possible_key

  显示可能应用在这张表上的索引，一个或多个。

* key

  实际使用的索引I，如果为NULL，则没有使用索引。

* key_len

  表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。

* rows

  MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。

* filtered

  表示返回结果的行数占需读取行数的百分比，filtered的值越大越好。

## 索引使用

### 最左前缀法则

如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效(后面的字段索引失效)。

### 范围查询

联合索引|中，出现范围查询(>，<)，范围查询右侧的列索引失效

### 索引列运算

不要在索引列上进行运算操作，索引将失效。

### 字符串不加引号

字符串类型字段使用时，不加引号，索引将失效。

### 模糊查询

如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。

### or连接的条件

用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。

### 数据分布影响

如果MySQL评估使用索引比全表更慢，则不使用索引。

### SQL提示

SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。

```sql
--use index;
explain select * from tb_user use index(idx_user_pro) where profession = ' ';--建议使用指定idx
--ignore index;
explain select * from tb_user ignore index(idx_user_pro) where profession = ' ';--不使用指定idx
--force index;
explain select * from tb_user force index(idx_user_pro) where profession = ' ';--必须使用指定idx
```

### 覆盖索引

尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到），减少select*

`using index condition`:查找使用了索引，但是需要回表查询数据  
`using where;using index`:查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据

### 前缀索引

当字段类型为字符串（varchar，text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘lO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。

```sql
create index idx_xxxx on table_name(column(n));--设置前缀长度为n的前缀索引
```

* 前缀长度

  可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，  
  唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

  ```sql
  select count(distinct email) / count(*) from tb_user;
  select count(distinct substring(email,1,5))/count(*) from tb_user;
  ```

  可以平衡选择性和截取长度

### 索引设计原则

1. 针对于数据量较大，且查询比较频繁的表建立索引。
2. 针对于常作为查询条件（where）、排序（orderby）、分组（groupby）操作的字段建立索引。
3. 量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
4. 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。
5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。
7. 如果索引列不能存储NULL值，请在创建表时使用NOTNULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。

# 范式

## 1NF

每一列都是不可分割的原子数据项

> 好理解，即每列含义唯一。

## 函数依赖

`A->B`如果A属性/属性组可以唯一确定B属性的值，则可以称为B依赖于A

- 完全函数依赖：如果A是一个属性组，则B的确定需要依赖A中所有属性
- 部分函数依赖：……，则B的确定需要依赖A中部分属性
- 传递函数依赖`A->B->C`

## 码

一个属性/属性组，被其他所有属性**完全函数依赖**，则这个属性/属性组为该表候选码（简称码）

- 主属性码：所有候选码中挑一个做主码（主键）
- 非属性码：除了主码属性组以外的属性

## 2NF

在1NF基础上，非属性码的属性必须**完全依赖**主码

## 3NF

在2NF基础上，消除传递依赖
